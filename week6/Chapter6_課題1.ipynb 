{"cells":[{"cell_type":"markdown","metadata":{"id":"D9zhTEa_GWjI"},"source":["### 演習課題1【必須】\n","\n","6.4.6節で実装したCNNの構造を変えてみましょう。精度改善を目指しているのではなく、構造を変えても動くようにするのが目的です！\n","\n","例えば、畳み込み層のチャンネル数、カーネルサイズを変えてみたり、畳み込み層を追加してみたりしてください。次元数を合わせるのがポイントです！"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"NAPBq63iGWjJ"},"outputs":[],"source":["import torch\n","import torch.nn as nn\n","import torch.nn.functional as F\n","import torch.optim as optim\n","from torchvision import datasets, transforms\n","from torch.utils.data import DataLoader\n","import matplotlib.pyplot as plt\n","import numpy as np\n","import random\n","\n","# ----- ランダムシード固定 -----\n","def seed_everything(seed=42):\n","    random.seed(seed)\n","    np.random.seed(seed)\n","    torch.manual_seed(seed)\n","    torch.cuda.manual_seed(seed)\n","    torch.cuda.manual_seed_all(seed)  # multi-GPU用\n","    torch.backends.cudnn.deterministic = True\n","    torch.backends.cudnn.benchmark = False\n","\n","seed_everything(42)\n","\n","# ----- データの読み込み -----\n","transform = transforms.Compose([\n","    transforms.ToTensor(),\n","    transforms.Normalize((0.1307,), (0.3081,))\n","])\n","\n","g = torch.Generator()\n","g.manual_seed(42)\n","\n","train_dataset = datasets.MNIST(root='./data', train=True, download=True, transform=transform)\n","test_dataset = datasets.MNIST(root='./data', train=False, download=True, transform=transform)\n","\n","train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True, generator=g)\n","test_loader = DataLoader(test_dataset, batch_size=1000, shuffle=False, generator=g)\n","\n","# ----- CNN モデル定義 -----\n","class SimpleCNN(nn.Module):\n","    def __init__(self):\n","        super(SimpleCNN, self).__init__()\n","        self.conv1 = nn.Conv2d(1, 15, kernel_size=7)  # nn.Conv2d(入力チャンネル数, 出力チャンネル数, kernel_size)\n","        self.conv2 = nn.Conv2d(15, 27, kernel_size=7) # 入力チャンネル数は、前層の出力チャンネル数と一致させる\n","        self.fc1 = nn.Linear(108, 50)\n","        self.fc2 = nn.Linear(50, 10)\n","\n","    def forward(self, x):\n","        x = F.relu(self.conv1(x))       # (batch, 20, 24, 24)   # 畳み込み：5x5レイヤーで両端の2列ずつ分小さくなる\n","        x = F.max_pool2d(x, 2)          # (batch, 20, 12, 12)   # 最大値プーリング：2x2領域の中の最大値を取って圧縮\n","        x = F.relu(self.conv2(x))       # (batch, 20, 8, 8)     # 畳み込み：5x5レイヤーで両端の2列ずつ分小さくなる\n","        x = F.max_pool2d(x, 2)          # (batch, 20, 4, 4)     # 最大値プーリング：2x2領域の中の最大値を取って圧縮\n","        x = x.view(-1, 108)             # (batch, 4x4x20=320)   # 平坦化：縦x横xチャンネル\n","        x = F.relu(self.fc1(x))         # (batch, 50)           # 各要素に非線形活性化 φ = relu()\n","        x = self.fc2(x)                 # (batch, 10)           # 10クラス分類\n","        return x\n","\n","# ----- 学習準備 -----\n","device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n","model = SimpleCNN().to(device)\n","optimizer = optim.Adam(model.parameters(), lr=0.001)\n","criterion = nn.CrossEntropyLoss()\n","\n","# ----- 訓練前のカーネルを可視化するために保存しておく -----\n","with torch.no_grad():\n","    initial_kernels = model.conv1.weight.cpu().clone()\n","\n","# ----- 学習ループ -----\n","epochs = 10\n","train_losses = []\n","test_losses = []\n","\n","for epoch in range(epochs):\n","    model.train()\n","    total_loss = 0\n","    correct = 0\n","    total = 0\n","\n","    for data, target in train_loader:\n","        data, target = data.to(device), target.to(device)\n","\n","        optimizer.zero_grad()\n","        output = model(data)\n","        loss = criterion(output, target)\n","        loss.backward()\n","        optimizer.step()\n","\n","        total_loss += loss.item()\n","\n","        # 正答率の計算\n","        pred = output.argmax(dim=1, keepdim=True)  # 最大スコアのクラスを取得\n","        correct += pred.eq(target.view_as(pred)).sum().item()\n","        total += target.size(0)\n","\n","    train_loss = total_loss / len(train_loader)\n","    train_accuracy = 100. * correct / total\n","    train_losses.append(train_loss)\n","\n","\n","    model.eval()\n","    test_loss = 0\n","    correct = 0\n","\n","    with torch.no_grad():\n","        for data, target in test_loader:\n","            data, target = data.to(device), target.to(device)\n","            output = model(data)\n","            test_loss += criterion(output, target).item()\n","            pred = output.argmax(dim=1, keepdim=True)\n","            correct += pred.eq(target.view_as(pred)).sum().item()\n","\n","    test_loss /= len(test_loader)\n","    test_losses.append(test_loss)\n","    test_accuracy = 100. * correct / len(test_dataset)\n","    print(f'Epoch {epoch+1}, Train Loss: {train_loss:.4f}, Train Accuracy: {train_accuracy:.2f}%, Test Loss: {test_loss:.4f}, Test Accuracy: {test_accuracy:.2f}%')\n","\n","# ----- 損失グラフの描画 -----\n","plt.figure(figsize=(6,4))\n","plt.plot(train_losses, label='Training Loss')\n","plt.plot(test_losses, label='Test Loss')\n","plt.xlabel('Epoch')\n","plt.ylabel('Loss')\n","plt.title('Loss over Epochs')\n","plt.legend()\n","plt.grid(True)\n","plt.show()\n","\n","# ----- カーネル（第1層）可視化 -----\n","with torch.no_grad():\n","    kernels = model.conv1.weight.cpu().clone()  # (out_channels, in_channels, H, W)\n","\n","num_kernels = min(20, kernels.shape[0])\n","cols = 10\n","rows = (num_kernels + cols - 1) // cols\n","\n","plt.figure(figsize=(1.5 * cols, 1.5 * rows))\n","for i in range(num_kernels):\n","    plt.subplot(rows, cols, i + 1)\n","    plt.imshow(initial_kernels[i][0], cmap='gray')  # 1チャンネルのカーネル\n","    plt.axis('off')\n","plt.suptitle('Initial Kernels in Conv1')\n","plt.tight_layout()\n","plt.show()\n","\n","plt.figure(figsize=(1.5 * cols, 1.5 * rows))\n","for i in range(num_kernels):\n","    plt.subplot(rows, cols, i + 1)\n","    plt.imshow(kernels[i][0], cmap='gray')  # 1チャンネルのカーネル\n","    plt.axis('off')\n","plt.suptitle('Trained Kernels in Conv1')\n","plt.tight_layout()\n","plt.show()"]}],"metadata":{"colab":{"provenance":[{"file_id":"1pmeY4c_OhuTgjhPJYuMHUp-GJX3MrKk-","timestamp":1749052203722}]},"kernelspec":{"display_name":"Python 3 (ipykernel)","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.8"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":false,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{},"toc_section_display":true,"toc_window_display":true}},"nbformat":4,"nbformat_minor":0}